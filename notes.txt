JUnit - Leveraging Test Lifecycle:

    Usually each Testcase (Test) will be run in their own class instance
    if there are 3 Tests in a class, then there will be three class instance created to
    run each separated from each other. Simplest and easiest mode to run all Tests

    There is the possibility to run PER_CLASS, but for pure unit testing it would not be needed

######

JUnit Lifecycle Methods (with the following order):
    - @BeforeAll (once in a Testclass before all Tests are started)
    - @AfterAll (once after all Tests in a Testclass are finished)
    - @BeforeEach (before each individual Test method is run)
    - @AfterEach (after each individual Test method is performed)

    These annotations are used to create Methods that can perform
    common setup or teardown code needed before and after tests run

Example:

class MyTest {
    @BeforeAll
    static void initAll() {...}

    @BeforeEach
    void init() {...}

    @Test
    void test1() {..}

    @Test
    void test2() {..}

    @AfterEach
    void teardown() {..}

    @AfterAll
    static void teardownAll() {..}
}

Execution:

    1. initAll()

    2. init() -> test1() -> teardown()

    3. init() -> test2() -> teardown()

    4. teardownAll()

######

JUnit Test Control Capabilities:

    New Test Types:

    **  - Parameterized Tests (multiple test runs with different data)
        - Repeated tests (load / performance tests)
        - Dynamic tests (create test "on the fly" or runtime)

    Test Execution Control:

    **  - Execute tests conditionally (disable test methods or decide on a condition which tests needs to run)
        - Control the order of test execution
        - Impose timeouts on tests (can be useful by performance testing)
        - Execute tests in parallel

    (most likely to be used are marked by **)

######

Parameterized Tests:

    Achieved through annotations

    Numerous ways to provide arguments:
        - @ValueSource
        - @Null and @Empty
        - @EnumSource
        - @MethodSource
        - @CsvSource
        - @CsvFileSource
        - @ArgumentsSource
        EACH INVOCATION HAS TEST LIFECYCLE

#####

Test Report Guidelines

    - Keep console output in tests to a minimum -> to keep it clearly laid out
    - What a test is for - what it's testing - should be as clear as possible in the report
        -> clear name for test method
        - In this Branch we'll cover display names and nested tests in this module
    - When there's a failure, the failure message in the report should be clear
        - We'll cover using custom failure messages in this module

    Common reasons to use a failure message:

        - to make what the test is for more clear when there is a failure
        - to detail the scenario and arguments
        - when there's a failure, the failure message in the report should be clear

#####

Some Unit testing Benefits

    - Aid in design
    - Document purpose of code
    - Give confidence to change code

########

Learning MOre:
    -> Test Driven Development
    -> Best Practices
